name: Deploy to Cloudflare Pages

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  deployments: write

jobs:
  # Job 1: Fix markdown frontmatter dates
  fix-dates:
    name: Fix Markdown Dates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for Git dates
          
      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Add missing dates to markdown files
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          function processMarkdownFiles(dir) {
            if (!fs.existsSync(dir)) {
              console.log(`Directory does not exist: ${dir}`);
              return;
            }

            const files = fs.readdirSync(dir, { withFileTypes: true });

            for (const file of files) {
              const fullPath = path.join(dir, file.name);

              if (file.isDirectory()) {
                processMarkdownFiles(fullPath);
              } else if (file.name.endsWith('.md')) {
                processFile(fullPath);
              }
            }
          }

          function processFile(filePath) {
            console.log(`\nProcessing: ${filePath}`);
            let content = fs.readFileSync(filePath, 'utf8');

            // Check if file has frontmatter
            if (!content.startsWith('---')) {
              console.log(`  ‚è≠Ô∏è  No frontmatter found, skipping`);
              return;
            }

            const frontmatterEnd = content.indexOf('---', 3);
            if (frontmatterEnd === -1) {
              console.log(`  ‚è≠Ô∏è  Malformed frontmatter, skipping`);
              return;
            }

            const frontmatter = content.substring(3, frontmatterEnd);
            const body = content.substring(frontmatterEnd + 3);

            // Get Git creation date (first commit) in ISO 8601 format
            let creationDate;
            try {
              const gitDate = execSync(
                `git log --follow --format=%aI --reverse "${filePath}" | head -1`,
                { encoding: 'utf8' }
              ).trim();
              creationDate = gitDate || new Date().toISOString();
            } catch (e) {
              creationDate = new Date().toISOString();
            }

            console.log(`  üìÖ Git creation date: ${creationDate}`);

            // Parse frontmatter into lines and build a clean version
            const lines = frontmatter.split('\n');
            const cleanedLines = [];
            let hasPublished = false;
            let hasPubDatetime = false;
            let hasAuthor = false;
            let needsFix = false;

            for (const line of lines) {
              const trimmedLine = line.trim();

              // Skip empty lines at the start
              if (!trimmedLine && cleanedLines.length === 0) {
                continue;
              }

              // Check for 'published' field
              const publishedMatch = trimmedLine.match(/^published:\s*(.+)$/);
              
              // Check for 'pubDatetime' field
              const pubDatetimeMatch = trimmedLine.match(/^pubDatetime:\s*(.+)$/);
              
              // Check for 'author' field
              const authorMatch = trimmedLine.match(/^author:\s*(.+)$/);

              if (publishedMatch) {
                console.log(`  üîç Found 'published' field`);

                if (hasPublished) {
                  console.log(`  ‚ùå Removing duplicate 'published' field`);
                  needsFix = true;
                  continue;
                }

                const rawValue = publishedMatch[1].trim();
                const existingDate = rawValue.replace(/^['"]|['"]$/g, '');

                if (!existingDate.includes('T') || rawValue.startsWith("'") || rawValue.startsWith('"')) {
                  console.log(`  üîß Fixing published date format: ${rawValue} -> ${creationDate}`);
                  cleanedLines.push(`published: ${creationDate}`);
                  needsFix = true;
                } else {
                  console.log(`  ‚úÖ Date format is correct`);
                  cleanedLines.push(line);
                }

                hasPublished = true;
              } else if (pubDatetimeMatch) {
                console.log(`  üîç Found 'pubDatetime' field`);

                if (hasPubDatetime) {
                  console.log(`  ‚ùå Removing duplicate 'pubDatetime' field`);
                  needsFix = true;
                  continue;
                }

                const rawValue = pubDatetimeMatch[1].trim();
                const existingDate = rawValue.replace(/^['"]|['"]$/g, '');

                if (!existingDate.includes('T') || rawValue.startsWith("'") || rawValue.startsWith('"')) {
                  console.log(`  üîß Fixing pubDatetime date format: ${rawValue} -> ${creationDate}`);
                  cleanedLines.push(`pubDatetime: ${creationDate}`);
                  needsFix = true;
                } else {
                  console.log(`  ‚úÖ Date format is correct`);
                  cleanedLines.push(line);
                }

                hasPubDatetime = true;
              } else if (authorMatch) {
                console.log(`  üë§ Found 'author' field`);
                cleanedLines.push(line);
                hasAuthor = true;
              } else {
                // Keep other fields as-is
                cleanedLines.push(line);
              }
            }

            // Add 'published' if it doesn't exist (and pubDatetime doesn't exist either)
            if (!hasPublished && !hasPubDatetime) {
              console.log(`  ‚ûï Adding missing 'published' field`);
              cleanedLines.push(`published: ${creationDate}`);
              needsFix = true;
            }

            // Add 'author' if it doesn't exist
            if (!hasAuthor) {
              console.log(`  ‚ûï Adding missing 'author' field`);
              cleanedLines.push(`author: Your Name`);
              needsFix = true;
            }

            if (needsFix) {
              console.log(`  üíæ Writing fixes to file...`);
              // Rebuild frontmatter ensuring no extra blank lines at start
              let newFrontmatter = cleanedLines.join('\n').trim();
              const newContent = `---\n${newFrontmatter}\n---${body}`;
              fs.writeFileSync(filePath, newContent, 'utf8');
              console.log(`  ‚úÖ File updated successfully`);
            } else {
              console.log(`  ‚úÖ No changes needed`);
            }
          }

          // Process content directory
          const contentDirs = ['src/content/posts', 'src/content/blog'];
          console.log('üîç Starting to scan for markdown files...\n');
          for (const dir of contentDirs) {
            console.log(`\nüìÅ Checking directory: ${dir}`);
            if (fs.existsSync(dir)) {
              processMarkdownFiles(dir);
            }
          }

          console.log('\n‚ú® Date adding process complete!');
          EOF

      - name: Fix date formats (timezone to UTC)
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');

          function processMarkdownFiles(dir) {
            if (!fs.existsSync(dir)) {
              console.log(`Directory does not exist: ${dir}`);
              return;
            }
            
            const files = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const file of files) {
              const fullPath = path.join(dir, file.name);
              
              if (file.isDirectory()) {
                processMarkdownFiles(fullPath);
              } else if (file.name.endsWith('.md')) {
                processFile(fullPath);
              }
            }
          }

          function processFile(filePath) {
            console.log(`\nProcessing: ${filePath}`);
            let content = fs.readFileSync(filePath, 'utf8');
            
            // Check if file has frontmatter
            if (!content.startsWith('---')) {
              console.log(`  ‚è≠Ô∏è  No frontmatter found, skipping`);
              return;
            }

            const frontmatterEnd = content.indexOf('---', 3);
            if (frontmatterEnd === -1) {
              console.log(`  ‚è≠Ô∏è  Malformed frontmatter, skipping`);
              return;
            }

            const frontmatter = content.substring(3, frontmatterEnd);
            const body = content.substring(frontmatterEnd + 3);

            // Process frontmatter line by line
            const lines = frontmatter.split('\n');
            const cleanedLines = [];
            let needsFix = false;

            for (const line of lines) {
              const trimmedLine = line.trim();
              
              // Skip empty lines at the start
              if (!trimmedLine && cleanedLines.length === 0) {
                continue;
              }

              // Check for published, modDatetime, or pubDatetime fields
              const dateMatch = trimmedLine.match(/^(published|pubDatetime|modDatetime):\s*(.+)$/);
              
              if (dateMatch) {
                const fieldName = dateMatch[1];
                const rawValue = dateMatch[2].trim();
                
                // Remove quotes if present
                const dateValue = rawValue.replace(/^['"]|['"]$/g, '');
                
                // Skip empty date values
                if (!dateValue || dateValue === '') {
                  console.log(`  üóëÔ∏è  Removing empty ${fieldName} field`);
                  needsFix = true;
                  continue;
                }
                
                // Check if date has timezone offset (e.g., +13:00, -05:00)
                if (dateValue.match(/[+-]\d{2}:\d{2}$/)) {
                  console.log(`  üîß Converting ${fieldName} from timezone format to UTC`);
                  console.log(`     Old: ${dateValue}`);
                  
                  try {
                    // Parse the date and convert to UTC
                    const date = new Date(dateValue);
                    const utcDate = date.toISOString();
                    
                    console.log(`     New: ${utcDate}`);
                    cleanedLines.push(`${fieldName}: ${utcDate}`);
                    needsFix = true;
                  } catch (e) {
                    console.log(`     ‚ö†Ô∏è  Error parsing date, keeping original`);
                    cleanedLines.push(line);
                  }
                } else {
                  // Date is already in correct format or doesn't need conversion
                  cleanedLines.push(line);
                }
              } else {
                // Keep other fields as-is
                cleanedLines.push(line);
              }
            }

            if (needsFix) {
              console.log(`  üíæ Writing date format fixes to file...`);
              let newFrontmatter = cleanedLines.join('\n').trim();
              const newContent = `---\n${newFrontmatter}\n---${body}`;
              fs.writeFileSync(filePath, newContent, 'utf8');
              console.log(`  ‚úÖ File updated successfully`);
            } else {
              console.log(`  ‚úÖ No date format changes needed`);
            }
          }

          // Process content directories
          const contentDirs = ['src/content/posts', 'src/content/blog'];
          console.log('üîç Starting date format check...\n');
          for (const dir of contentDirs) {
            console.log(`\nüìÇ Checking directory: ${dir}`);
            if (fs.existsSync(dir)) {
              processMarkdownFiles(dir);
            }
          }

          console.log('\n‚ú® Date format fixing complete!');
          EOF

      - name: Commit and push changes
        run: |
          echo "üìã Checking for changes..."
          git status
          git add -A
          if git diff --staged --quiet; then
            echo "‚úÖ No changes to commit"
          else
            echo "üíæ Committing changes..."
            git commit -m "ü§ñ Auto-fix: Update markdown frontmatter dates" --no-verify
            echo "üöÄ Pushing changes..."
            git push
            echo "‚úÖ Changes pushed successfully"
          fi

  # Job 2: Build the Astro site
  build:
    name: Build Site
    needs: fix-dates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository with fixed dates
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('package.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install dependencies
        run: npm install

      - name: Format posts
        run: npm run format-posts

      - name: Build site
        run: npm run build

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist
          retention-days: 1

  # Job 3: Deploy to Cloudflare Pages
  deploy:
    name: Deploy to Cloudflare Pages
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: cloudflare-pages
      url: ${{ steps.deployment.outputs.url }}
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Deploy to Cloudflare Pages
        id: deployment
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy dist --project-name=ultimatetech --commit-dirty
